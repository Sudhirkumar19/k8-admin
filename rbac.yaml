apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
    namespace: expense
    name: expense-trainee
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
   # above verbs are read only permissions. If you want to give write permissions then you can add "create", "update", "delete" verbs in the above list.

# Now bind the role to the use using RoleBinding. RoleBinding is used to bind the role to the user or group or service account.

---

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
    name: expense-trainee
    namespace: expense
roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: Role
    name: expense-trainee
subjects:
- apiGroup: rbac.authorization.k8s.io # this is required to specify the api group for the user or group or service account. 
  kind: User
  name: sudhir # change to your name or email id which is used to login to the cluster. This will give the permissions defined in the role to the user.

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: expense
  name: expense-admin
rules:
- apiGroups: ["*"] # "" indicates the core all API group and "*" indicates all resources in that API group. So the above rule gives permissions to all resources in all API groups.
  resources: ["*"]
  verbs: ["*"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: expense-admin
  namespace: expense
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: expense-admin
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: User
  name: ramesh
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: expense
rules:
- apiGroups: [""] #core api group contains the following resources: pods, services, endpoints, configmaps, secrets, namespaces, nodes, persistentvolumes etc. So the above rule gives permissions to all resources in the core API group.
  resources: ["nodes","persistentvolumes","namespaces"]
  verbs: ["get","list","watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
# This cluster role binding allows anyone in the "manager" group to read secrets in any namespace.
kind: ClusterRoleBinding
metadata:
  name: expense
subjects:
- kind: User
  name: ramesh # Name is case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: expense
  apiGroup: rbac.authorization.k8s.io


# Two important points in RBAC are:

#1. EKS is intetergrated with IAM for authentication. So we can use IAM users and groups to authenticate to the cluster. But for authorization we have to use RBAC. So we can create roles and role bindings in the cluster to give permissions to the users and groups.

#2. aws-auth configmap is used to map the IAM users and groups to the Kubernetes users and groups. So we have to edit the aws-auth configmap to give permissions to the IAM users and groups to access the cluster. We can use kubectl edit configmap aws-auth -n kube-system command to edit the configmap and add the IAM users and groups in the mapUsers section. After editing the configmap we have to apply it to the cluster using kubectl apply -f aws-auth.yaml command.

## the architecture of RBAC in Kubernetes is as follows:

# 1. User or group or service account is authenticated to the cluster using IAM or other authentication mechanisms.

# 2. Once the user or group or service account is authenticated, then the RBAC system checks the roles and role bindings to see what permissions the user or group or service account has.

# 3. If the user or group or service account has the required permissions, then it can access the resources in the cluster. If not, then it will get a permission denied error.

# diagramatically represented as below:
# User or Group or Service Account --> Authentication --> RBAC System --> Authorization --> Access to Resources